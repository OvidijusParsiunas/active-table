update homepage property in package

detect React:
!!Object.keys(document).find(key => key.includes('react'))

when tabbing across cells, need the cursor to automatically point towards the end of the text

add the following eslint and prettier rule:
"@typescript-eslint/prefer-readonly": "error",
This will require parserServives it work

Could potentially use web workers to speed up processing

STRATEGY:

REF-1
cellStyle will only override the borders of inner table structure and not the outside of the table
These have been overriden in the css using !import
The reason for this is because the use of custom border left or border right styles would leave one of the side borders uncovered and the use of both would
result in thick middle borders
For the table borders to be set, use tableStyle

REF-2
contentEditable does not display the caret correctly in shadow dom in FireFox
the workaround is to set contentEditable every time the data cell is focused
alternatively can refactor cells to be inputs
https://pablo.berganza.dev/blog/shadow-dom-firefox-contenteditable/

REF-3
editable table component supports 2 date formats - d/m/y and m/d/y
to automatically infer which one to use we need to keep track of number of dates that apply to both we use the AllDateFormats
property. This prevents us from having to increment and decrement both d/m/y and m/d/y format properties which would would
heavily complicate the changeTypeAndSetColumnType method logic (as there are other formats such as number which applies
both to text and number, hence it would probably also have to be incremented/decrement for both for consistency).
The validation logic first checks the d/m/y and immediately returns it if it is valid, the parseType method additionally
checks if the cell value applies to m/d/y as well and if it does, it sets the format as 
Currently the primary date format is d/m/y so if all cells apply to both formats, that is the format that will be used

REF-4
Identified an issue where the scrollIntoView does not scroll down far enough to an element for it to be fully visible when
there is a horizontal scroll bar as it is partially covered by it. This appears to only happen when the parent element
(category dropdown) is displayed and we immediately proceed to scroll to an element.
The workaround for this is to identify that there is a horizontal scroll bar and programmatically scroll further down

REF-5
Category cells are the only ones that contain div text elements as they are needed to set the background color. The reason
why all cells do not contain a text element instead of a text node - which would tramendously simplify the complexity of
the text set/get logic in the app is because a text element within a cell has a drawback:
If one cell contains a lot of text and is resultantly very high, the text elements in the same row which do not contain that
much text and are inherntly shorter, would have white space fill up the rest of their cell's height.
If the user would click on that whitespace, the text editor caret would focus on the left of the text which looks bad.
Fortunately this can be fixed by shadowRoot.getSelection, however this is not available to all browsers. Hence, because
the UX cannot be made good for all browsers, the table will continue to use plane text within its data cells to have as
much of a better user experience as possible. It is true that in those instances the limitation will still be there when
category cells are used, but at least it will only be problematic in those specific cells.

REF-6
Knowing that data cell elements contain a text node and category cells a text element with a text node inside,
the .textContent grabs the text when used on the cell or the text element for all cases

REF-7
Because there is no way in firefox to distinguish if element focus was fired by tab key, the cellKeyEventState is used
to hold temporary state to indicate this. Primarily used to decide whether move caret via the setToEndOfText method

REF-8
The reason why there are multiple category dropdowns is because each one contains multiple items dependant on the column it
is on. Hence it is very inefficient to repopulate the dropdown when it is clicked on a different column cell.
// WORK - Perhaps store them in a dedicated parent instead of having them right with the body

REF-9
Relative positioning does not work on tbody in safari which causes absolute elements to use the screen

REF-10
SVG elements are constructed by parsing a string instead of using an actual file. This is because I did not want to introduce extra
plugins and bundling complexity for adding SVGs into the resultant bundle
Additionally not using the lit element way for inserting svg templates as it has been considered to potentially stop using lit
element and instead go native, hence the current approach of parsing a string will make it easier if moving to that direction
However if opted to stay with lit element - use the following approach: https://lit.dev/docs/api/templates/#svg

REF-11
Because the table is re-rendered when the user changes the parent width - the column width setting process has been optimised.
This has lead to a relatively complex code flow to only trigger the changeWidthsBasedOnColumnInsertRemove method once:
When maxWidth is set and narrow columns are not preserved - we must set the display style to 'block' in order for the table offset
to have the exact width as the temporarily set css width - otherwise the addition of initial columns will increase the table width
by 100 (default width) for each column and stop the canAddMore check from returning false as column widths will be above minimum.
(Executing changeWidthsBasedOnColumnInsertRemove after each column addition would prevent this but we do not want to execute
it every time for optimization)
(This is also why the display is set to 'block' when the client has set a specific width).
Finally, this is why we have the isNewText check in the InsertNewCell class and instead calling changeWidthsBasedOnColumnInsertRemove
once inside the TableElement class.

REF-12
The original architecture of a column sizer (known as the resizer to the user) allowed it to change the column width as it was moving,
however this was deemed too computationaly expensive when the table had many rows as the render speed was very slow, hence it was
rebuilt to only change column width once the user triggers a mouse up event.

Anatomy of a column sizer :
|               |       |        || |         | |           ||
|               |       |        || |         | |           ||
| cell divider  | sizer | filler || | overlay | |  movable  ||
|               |       |        || |         | |           ||
|               |       |        || |         | |           ||
|               |       |        || |         | |           ||

A cell divider contains a sizer and 2 other sizer related components that help it perform the functionality that it requires
The sizer element itself contains a filler element which is used to prevent a bug where during the entrance animation - the cell
border tends to bleed out onto the middle of the sizer causing its color to be visible
The sizer element itself does not have any events and all of them are actually performed on the sizer overlay. The reason for this
is because by default the sizer width is short, hence when the user tries to hover over it to have it expand - the area of hover
is actually really small and it may sometimes be hard to hover over it - this is where the overlay comes in and triggers the hover
event before the sizer element is actually reached - thus allowing better experience for the user.
The movable sizer element is the element that follows the cursor whilst the actual sizer element remains static in its position

REF-13
The process of adding adding a new column details object (ColumnDetailsT):
First creating the object with just the elements array in order to allow the changeWidthsBasedOnColumnInsertRemove method to
reset all column widths if required. Then in a timeout - asynchronously add all the other necessary details except the sizer
as its creation requires the details from that object. Later proceed to create the sizer and add it to the object, thus
completing the creation of that object.

REF-14
When calling super.connectedCallback() in the 'override connectedCallback' method - Firefox was initially found to call
the 'override render' twice - where the first render did not have the popylated properties that were passed by client.
This has been prevented by calling super.connectedCallback() inside a timeout.

REF-15
The reason why there are two types used to define the table dimensions is because we want one interface (TableDimensions) to be
exposed to the client to direct them on what values and types can be passed down and another type (TableDimensionsInternal) to
represent the values and their types after processing the client object in order to guide the development of this component.
The interfaces are auto generated, hence cannot control what is exposed to the client.

REF-16
In Chrome/Firefox: it has been identified that when there is no width set on the table - the default html does not allow the table
to expand beyond the parent limits (increase the parent width) and instead automatically reduces the column widths. This is
problematic as the widths are no longer what they are set to by the component and the resize functionality no longer works as
intended, hence the table-controlled-width class allows the table to expand the parent element and keep the intended column widths
This behaviour is still permitted when preserveNarrowColumns is set to true.
In Safari: This also serves as a fix for Safari table width bug and the table width no longer needs to be set for this browser.
Reference to this commit to undo anything that has been changed: 2fd86cd84f88d19e8a4a8a95c6b73e4fe181ad13
Snippet from a previous Ref:
(Safari has a bug where column widths for cell elements that contain wrapped text (text that oveflows the width) is increased to what
the width would be without the wrapping. This can be fixed by programmatically setting the table width based on the column widths.
I have raised a stack overflow question to see if this can be fixed automatically via plain css without a manual workaround:
https://stackoverflow.com/questions/73920147/table-element-width-using-column-widths-safari)

REF-17
The add column cell/button is made up of cells (number of rows in the table). The hover highlight functionality has been optimised
to not traverse all of the cells and highlight them individually (as that would be computationally expensive if there are many rows)
and instead utilise the column group functionality to control its highlight.
Column group is EXCLUSIVELY used for this purpose and other custom column background color is set cell by cell as it only needs
to be done once.

REF-18
The add row button is always in the table body and is converted into a no content stub and reconverted after it is clicked on.
The reasonings for this are explained here:
When there are no cells in the table, we display a stub element that the user can use to add the first element of the table.
The original idea was to have the column add cell act as the stub when it is set to be displayed or add new row cell to act when
the column is not displayed etc. However this idea was dismissed due to the code complexity this required as we needed code to
set and unset both of the cells' styles and have them work with the toggle logic for the max numbers. The second idea was to
use a standalone cell button that would independently appear when the table had no contents and would hide when content was
added again. This originally worked, but the logic behind displaying it and keeping the other cells hidden grew in complexity.
I then realised that this cell had an onclick event that would add a new row (a new column after no cells cannot be added)
which was pretty much just like the add new row button, so why really have another standalone cell if we can just reuse
the add new row button exclusively. Hence this is why the add row button is always present within the table body and all we do
is convert its style to a stub when there are no contents and set it back to normal or hide it when the contents are added.

REF-19
When the index column is too wide (and narrow columns are not preserved) - the table body will actually be increased over the size
of the table as the initial columns that have been added when the index column had a default width can no longer be removed. To
prevent this we reduce the index column back to its default width by allowing its numbers to wrap. Please note that unwrapping
detection is not supported and once the index column is wrapped it will stay in this form for the rest of the session.
If the table needs to be re-rendered due to resizing, we use the isColumnIndexCellTextWrapped state to check was it wrapped before
and if it was we wrap the index column from the getgo.
When preserveNarrowColumns is set to true and the table exceeds the set width, the column is set to wrap.
The client also has the ability to set the column to wrap all the time by using the wrapIndexCellText flag.

REF-20
onCellUpdate is specifically designed to help maintain a data object in the parent application and IS NOT meant to be used like
an alert notification system to report what has been specifically removed or added. The reason for this is because the update
messages that are sent don't actually describe the particular cells that have been removed/added are and instead describe what
changes need to be made to the outside data object in order for it to be the same as the data object (contents) in this component.
Example:
When there are 5 rows and 5 columns, and row number 3 gets removed - the messages that are sent out do not say that row 3 cells
were removed and instead they will say that row 3 cells were updated, row 4 was updated ad row 5 was the one that was removed.
Reasons for implementing onCellUpdate this way:
1. This allows the shadow component to be 100% clear on what happens inside it when a certain part of the table object is
manipulated and how the changes should be made on the parent object to keep it the same as API consumers can take the wrong path
of implementing their array splice functionality incorrectly which would leave their objects out of sync.
2. In state management solutions such as Redux - reducers should be pure functions and not something that would maintain existing
state. Hence incentivising users to implement array splicing and addition logic for state manipulation is something that we want
to avoid.
3. The simplicty, messages that are sent out denote exactly what cells need to be changed and not making the user solve the problem
of what else needs to be changed when one has been deleted/inserted at a particular table index. Hence, they should do exactly what
the messages tell them to and absolutely nothing else.

CAUTION-1
When considering the idea of allowing different columns to have different styles, take note of some of the assumed constants across
the table as they will no longer be constant and will need some dynamicity

CAUTION-2
When resizing the table, take note of some async code that was waiting to be executed before the resize was triggered:
It has been identified that when re-render occurs and columnsDetails object is cleared, by the time the async code is executed,
the columnDetails objects will already have the elements property populated again, however they will not have any other
properties (REF-13) which we can use to check if re-rendering has occured, and if it has - stop any further async processing
from execution.
If further bugs occur - create and use a 'rendering' flag instead.

CAUTION-3
Table dimensions have exclusive optional interfaces that are exposed to the client, however they may not be respected, hence the logic
needs to be cautious when handling the passed in object

CAUTION-4
Do not set state/property variables after render has occurred as it will trigger full component re-render
Be careful when assigning element references and instead do them in the connectedCallback method

Accepted behaviour

When a table column is squished - the increased height can create a scrollbar in the parent - this will trigger a re-render in the table
and cause the column widths to be reset (or be even smaller if using maxWidth as the new re-render is using the new table width that may
not breach the maxWdith threshold). Because we do not record column widths in-state, there is currently no way to track back what the
original widths were and they will be forced to reset.
TO-DO can potentially keep track of the column widths and reset the correctly in the future
