update homepage property in package

detect React:
!!Object.keys(document).find(key => key.includes('react'))

when tabbing across cells, need the cursor to automatically point towards the end of the text

add the following eslint and prettier rule:
"@typescript-eslint/prefer-readonly": "error",
This will require parserServives it work

Could potentially use web workers to speed up processing

STRATEGY:

REF-1
cellStyle will only override the borders of inner table structure and not the outside of the table
These have been overriden in the css using !import
The reason for this is because the use of custom border left or border right styles would leave one of the side borders uncovered and the use of both would
result in thick middle borders
For the table borders to be set, use tableStyle

REF-2
contentEditable does not display the caret correctly in shadow dom in FireFox
the workaround is to set contentEditable every time the data cell is focused
alternatively can refactor cells to be inputs
https://pablo.berganza.dev/blog/shadow-dom-firefox-contenteditable/

REF-3
editable table component supports 2 date formats - d/m/y and m/d/y
to automatically infer which one to use we need to keep track of number of dates that apply to both we use the AllDateFormats
property. This prevents us from having to increment and decrement both d/m/y and m/d/y format properties which would would
heavily complicate the changeTypeAndSetColumnType method logic (as there are other formats such as number which applies
both to text and number, hence it would probably also have to be incremented/decrement for both for consistency).
The validation logic first checks the d/m/y and immediately returns it if it is valid, the parseType method additionally
checks if the cell value applies to m/d/y as well and if it does, it sets the format as 
Currently the primary date format is d/m/y so if all cells apply to both formats, that is the format that will be used

REF-4
Identified an issue where the scrollIntoView does not scroll down far enough to an element for it to be fully visible when
there is a horizontal scroll bar as it is partially covered by it. This appears to only happen when the parent element
(category dropdown) is displayed and we immediately proceed to scroll to an element.
The workaround for this is to identify that there is a horizontal scroll bar and programmatically scroll further down

REF-5
Category cells are the only ones that contain div text elements as they are needed to set the background color. The reason
why all cells do not contain a text element instead of a text node - which would tramendously simplify the complexity of
the text set/get logic in the app is because a text element within a cell has a drawback:
If one cell contains a lot of text and is resultantly very high, the text elements in the same row which do not contain that
much text and are inherntly shorter, would have white space fill up the rest of their cell's height.
If the user would click on that whitespace, the text editor caret would focus on the left of the text which looks bad.
Fortunately this can be fixed by shadowRoot.getSelection, however this is not available to all browsers. Hence, because
the UX cannot be made good for all browsers, the table will continue to use plane text within its data cells to have as
much of a better user experience as possible. It is true that in those instances the limitation will still be there when
category cells are used, but at least it will only be problematic in those specific cells.

REF-6
Knowing that data cell elements contain a text node and category cells a text element with a text node inside,
the .textContent grabs the text when used on the cell or the text element for all cases

REF-7
Because there is no way in firefox to distinguish if element focus was fired by tab key, the cellKeyEventState is used
to hold temporary state to indicate this. Primarily used to decide whether move caret via the setToEndOfText method

REF-8
The reason why there are multiple category dropdowns is because each one contains multiple items dependant on the column it
is on. Hence it is very inefficient to repopulate the dropdown when it is clicked on a different column cell.

REF-9
Relative positioning does not work on tbody in safari which causes absolute elements to use the screen

REF-10
SVG elements are constructed by parsing a string instead of using an actual file. This is because I did not want to introduce extra
plugins and bundling complexity for adding SVGs into the resultant bundle
Additionally not using the lit element way for inserting svg templates as it has been considered to potentially stop using lit
element and instead go native, hence the current approach of parsing a string will make it easier if moving to that direction
However if opted to stay with lit element - use the following approach: https://lit.dev/docs/api/templates/#svg

REF-11
Safari has a bug where column widths for cell elements that contain wrapped text (text that oveflows the width) is increased to what
the width would be without the wrapping. This has been fixed by programmatically setting the table width based on the column widths.
I have raised a stack overflow question to see if this can be fixed automatically via plain css without a manual workaround:
https://stackoverflow.com/questions/73920147/table-element-width-using-column-widths-safari

REF-12
The original architecture of a column sizer (known as the resizer to the user) allowed it to change the column width as it was moving,
however this was deemed too computationaly expensive when the table had many rows as the render speed was very slow, hence it was
rebuilt to only change column width once the user triggers a mouse up event.

Anatomy of a column sizer :
|               |       |        || |         | |           ||
|               |       |        || |         | |           ||
| cell divider  | sizer | filler || | overlay | |  movable  ||
|               |       |        || |         | |           ||
|               |       |        || |         | |           ||
|               |       |        || |         | |           ||

A cell divider contains a sizer and 2 other sizer related components that help it perform the functionality that it requires
The sizer element itself contains a filler element which is used to prevent a bug where during the entrance animation - the cell
border tends to bleed out onto the middle of the sizer causing its color to be visible
The sizer element itself does not have any events and all of them are actually performed on the sizer overlay. The reason for this
is because by default the sizer width is short, hence when the user tries to hover over it to have it expand - the area of hover
is actually really small and it may sometimes be hard to hover over it - this is where the overlay comes in and triggers the hover
event before the sizer element is actually reached - thus allowing better experience for the user.
The movable sizer element is the element that follows the cursor whilst the actual sizer element remains static in its position

REF-13
The process of adding adding a new column details object (ColumnDetailsT):
First creating the object with just the header element in order to allow the changeWidthsBasedOnColumnInsertRemove method to reset
all column widths if required. Then in a timeout - asynchronously add all the other necessary details except the sizer as its
creation requires the details from that object. Then proceed to create the sizer and after creating it add it to the object,
thus completing the creation of that object.

REF-14
Cannot overwrite the table element style (via tableStyle) on render in FireFox, hence the intitial setup for overwriting the style
is done in timeouts. This has also caused the initial column width setup code to be moved to a timeout and not be executed on
adding the individual columns as it depends on the TOTAL_HORIZONTAL_SIDE_BORDER_WIDTH on being calculated correctly. However,
all proceeding column lengths and table width for Safari are changed directly when a column has been added or removed.



CAUTION-1
When considering the idea of allowing different columns to have different styles, take note of some of the assumed constants across
the table as they will no longer be constant and will need some dynamicity